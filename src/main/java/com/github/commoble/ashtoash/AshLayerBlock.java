package com.github.commoble.ashtoash;

import java.util.Random;

import net.minecraft.block.Block;
import net.minecraft.block.BlockPlacementEnvironment;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.entity.EntityContext;
import net.minecraft.item.ItemPlacementContext;
import net.minecraft.state.StateFactory;
import net.minecraft.state.property.BooleanProperty;
import net.minecraft.state.property.IntProperty;
import net.minecraft.state.property.Properties;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.shape.VoxelShape;
import net.minecraft.util.shape.VoxelShapes;
import net.minecraft.world.BlockView;
import net.minecraft.world.IWorld;
import net.minecraft.world.ViewableWorld;
import net.minecraft.world.World;

public class AshLayerBlock extends Block
{
	public static final IntProperty LAYERS = Properties.LAYERS;
	public static final BooleanProperty NATURAL = BooleanProperty.of("natural");	// true if generated by burning, false if placed by player
	public final BlockState FRESH_BURNED_ASH;
	
	// from SnowBlock
	public static final VoxelShape[] LAYERS_TO_SHAPE = new VoxelShape[] {
		VoxelShapes.empty(),
		Block.createCuboidShape(0.0D, 0.0D, 0.0D, 16.0D, 2.0D, 16.0D),
		Block.createCuboidShape(0.0D, 0.0D, 0.0D, 16.0D, 4.0D, 16.0D),
		Block.createCuboidShape(0.0D, 0.0D, 0.0D, 16.0D, 6.0D, 16.0D),
		Block.createCuboidShape(0.0D, 0.0D, 0.0D, 16.0D, 8.0D, 16.0D),
		Block.createCuboidShape(0.0D, 0.0D, 0.0D, 16.0D, 10.0D, 16.0D),
		Block.createCuboidShape(0.0D, 0.0D, 0.0D, 16.0D, 12.0D, 16.0D),
		Block.createCuboidShape(0.0D, 0.0D, 0.0D, 16.0D, 14.0D, 16.0D),
		Block.createCuboidShape(0.0D, 0.0D, 0.0D, 16.0D, 16.0D, 16.0D)
		};
	
	public AshLayerBlock(Block.Settings settings)
	{
		super(settings);
		this.setDefaultState(this.stateFactory.getDefaultState().with(LAYERS, 1).with(NATURAL, false));
		this.FRESH_BURNED_ASH = this.stateFactory.getDefaultState().with(LAYERS, 1).with(NATURAL, true);
	}
	
	// attempt to generate ash on the best spot below the burned block, using these rules:
	// 0) search downward until one of these things is found
	// 1) if a solid block is found, do not place ash
	// 2) if ash is found w/ layers < 8, increment layers
	// 3) if an air block that ash can be placed at is found, place it there
	public static void tryToGenerateAsh(World world, BlockPos pos)
	{
		BlockState state = world.getBlockState(pos);
		if (state.isFullOpaque(world, pos) || pos.getY() <= 0)
		{
			return;
		}
		else if (state.getBlock() == BlockRegistrar.ASH)
		{
			int layers = state.get(LAYERS);
			if (layers < 8)
			{
				world.setBlockState(pos, state.with(LAYERS, layers+1));
				return;
			}
			else
			{
				return;
			}
		}
		else if (world.isAir(pos) && BlockRegistrar.ASH.canPlaceAt(state, world, pos) && world.getBlockState(pos.down()).isOpaque())
		{
			world.setBlockState(pos, BlockRegistrar.ASH.FRESH_BURNED_ASH);
			return;
		}
		else
		{
			tryToGenerateAsh(world, pos.down());
		}
	}

	@Override
	public boolean canPlaceAtSide(BlockState world, BlockView view, BlockPos pos, BlockPlacementEnvironment env)
	{
		switch (env)
		{
			case LAND:
				return world.get(LAYERS) < 5;
			case WATER:
				return false;
			case AIR:
				return false;
			default:
				return false;
		}
	}

	@Override
	public VoxelShape getOutlineShape(BlockState state, BlockView view, BlockPos pos, EntityContext ePos)
	{
		return LAYERS_TO_SHAPE[state.get(LAYERS)];
	}

	@Override
	public VoxelShape getCollisionShape(BlockState state, BlockView view, BlockPos pos, EntityContext ePos)
	{
		return LAYERS_TO_SHAPE[state.get(LAYERS)];
	}

	@Override
	public boolean hasSidedTransparency(BlockState state)
	{
		return true;
	}

	@Override
	public boolean canPlaceAt(BlockState state, ViewableWorld world, BlockPos pos)
	{
		BlockState groundState = world.getBlockState(pos.down());
		return Block.isFaceFullSquare(groundState.getCollisionShape(world, pos), Direction.UP)
			|| (groundState.getProperties().contains(LAYERS) && groundState.get(LAYERS) == 8);

	}

	@Override
	public BlockState getStateForNeighborUpdate(BlockState state, Direction facing, BlockState neighborState, IWorld world, BlockPos pos, BlockPos neighborPos)
	{
		return !state.canPlaceAt(world, pos) ? Blocks.AIR.getDefaultState() : super.getStateForNeighborUpdate(state, facing, neighborState, world, pos, neighborPos);
	}

	@Override
	public void onScheduledTick(BlockState state, World world, BlockPos pos, Random random)
	{
		if (!world.isClient && this.canAshBlowAway(state, world, pos))
		{
			int layers = state.get(LAYERS);
			if (layers > 0)
			{
				world.setBlockState(pos, state.with(LAYERS, layers-1));
			}
			else
			{
				world.clearBlockState(pos, false);
			}
		}
	}

	// ash slowly blows away if:
		// ash is outdoors, and
		// ash is NATURAL, and
		// ash is not smallest layer level (including lower layers), and
		// ash is not a full block with more ash above
	public boolean canAshBlowAway(BlockState state, World world, BlockPos pos)
	{
		return state.getProperties().contains(NATURAL)
			&& state.get(NATURAL)
			&& !this.isSmallestAshLayer(state, world, pos)
			&& !world.isAir(pos.up())
			&& world.isSkyVisible(pos);
	}
	
	
	/** Precondition: Blockstate has NATURAL property **/
	public boolean isSmallestAshLayer(BlockState state, World world, BlockPos pos)
	{
		return state.get(LAYERS) == 1 && world.getBlockState(pos.down()).getBlock() != this;
	}

	@Override
	public boolean canReplace(BlockState state, ItemPlacementContext ctx)
	{
		int i = state.get(LAYERS);
		if (ctx.getStack().getItem() == this.asItem() && i < 8)
		{
			if (ctx.canReplaceExisting())
			{
				return ctx.getSide() == Direction.UP;
			}
			else
			{
				return true;
			}
		}
		else
		{
			return i == 1;
		}
	}

	@Override
	public BlockState getPlacementState(ItemPlacementContext ctx)
	{
		BlockState blockState = ctx.getWorld().getBlockState(ctx.getBlockPos());
		if (blockState.getBlock() == this)
		{
			int i = blockState.get(LAYERS);
			return blockState.with(LAYERS, Math.min(8, i + 1));
		}
		else
		{
			return super.getPlacementState(ctx);
		}
	}

	@Override
	protected void appendProperties(StateFactory.Builder<Block, BlockState> builder)
	{
		builder.add(LAYERS, NATURAL);
	}
}
